## 基本概念
### 1.树节点的度数
树节点的度数就是这个树节点有多少子节点

&nbsp;
### 2.完全二叉树(Complete Binary Tree)
完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，
几乎每次都要考到的二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

**定义**：*一棵深度为k的有n个结点的二叉树，对树中的结点**按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同**，则这棵二叉树称为完全二叉树*。  
（直接看图片对比很清晰）

一棵二叉树至多只有最下面的两层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，则此二叉树成为完全二叉树。  
（***相同表述***：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。）

&nbsp;
### 3.二叉查找树
二叉树的提出其实主要就是为了提高查找效率，比如我们常用的 HashMap  在处理哈希冲突严重时，拉链过长导致查找效率降低，就引入了红黑树。

二分查找可以缩短查找的时间，**但是它要求 查找的数据必须是有序的**。每次查找、操作时都要维护一个有序的数据集，于是有了二叉查找树这个概念。

二叉查找树（又叫二叉排序树），它是具有下列性质的二叉树：
```
若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
左、右子树也分别为二叉排序树。
```
在最好的情况下，二叉排序树的查找效率比较高，是 O(logn)，其访问性能近似于折半查找；  
但最差时候会是 O(n)，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行（见下图 b）。

&nbsp;
### 4.平衡二叉树
平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：
```
平衡二叉树要么是一棵空树;
要么保证左右子树的高度之差不大于 1;
子树也必须是一颗平衡二叉树
```
也就是说，树的两个左子树的高度差别不会太大。

那我们接着看前面的极端情况的二叉排序树，现在用它来构造一棵平衡二叉树。

&nbsp;
### 5.堆（Heap）
堆就是用数组实现的二叉树，所有它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。  
堆的常用方法：
```
构建优先队列
支持堆排序
快速找出一个集合中的最小值（或者最大值）
在朋友面前装逼
```
堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式。  
在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。

堆属性非常的有用，因为堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素。
```
注意：堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。
例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。
--唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。
```
堆的相关代码详见[数据结构：堆（Heap）](https://www.jianshu.com/p/6b526aa481b1)

&nbsp;
## 堆和树的区别
<p>堆是一类特殊的树，堆的通用特点就是父节点会大于或小于所有子节点。</p><figure><noscript><img src="https://pic3.zhimg.com/50/v2-e7a99fda571a4294e9b2196d58f8e65c_hd.jpg" data-rawwidth="564" data-rawheight="564" class="origin_image zh-lightbox-thumb" width="564" data-original="https://pic2.zhimg.com/v2-e7a99fda571a4294e9b2196d58f8e65c_r.jpg"/></noscript><img src="data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;564&#39; height=&#39;564&#39;&gt;&lt;/svg&gt;" data-rawwidth="564" data-rawheight="564" class="origin_image zh-lightbox-thumb lazy" width="564" data-original="https://pic2.zhimg.com/v2-e7a99fda571a4294e9b2196d58f8e65c_r.jpg" data-actualsrc="https://pic3.zhimg.com/50/v2-e7a99fda571a4294e9b2196d58f8e65c_hd.jpg"/></figure>

首先说明一下，**堆并不一定是完全二叉树**，平时使用完全二叉树的原因是易于存储，并且便于索引。

所以大部分时间我们是使用完全二叉树来存储堆的，但是堆并不等于完全二叉树，例如二项堆，斐波那契堆，就不属于二叉树。

如果仅仅是需要得到一个有序的序列，使用排序就可以很快完成，并不需要去组织一个新的数据结构。
但是如果我们的需求是对于一个随时会有更新的序列，我要随时知道这个序列的最小值或最大值是什么。
显然如果是线性结构，每次插入之后，假设原数组是有序的，那使用二分把它放在正确的位置也未尝不可，
但是插入的时候从数组中留出空位就需要O(n)的时间复杂度，删除的时候亦然。

可是如果我们将序列看作是一个集合，我们需要的是这个集合的一个最小值，并且，在它被任意划分成为若干个子集的时候，
这些子集的最小值我们也是知道的，这些子集被不断划分，我们依然知道这些再次被划分出来的子集的最小值。
而且我们去想办法去保持这样的一个性质，那么这个问题是不是变得非常好解决了呢？  
那么问题就转换成了一种集合之间的关系，并且是非常明显的一种包含关系，那么最适合于解决这种集合上的关系的数据结构是什么呢？

那么就是树，所以就形成了这样的一种树，他的每一个节点都比它的子节点们小或者大。
当我们插入一个新的节点的时候，实际上  我们需要去调整的大部分时候只是这棵树上的一条路径，也就是决定它在哪一个集合里面，
树上的路径长度相对于这个集合，由于是对数级别的，所以非常可以接受，那么这种数据结构也就应运而生，这个数据结构就叫做堆

[堆和树有什么区别？](https://www.zhihu.com/question/36134980)

&nbsp;
## 二叉树遍历
对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。  

因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。
```
前序遍历：根结点 ---> 左子树 ---> 右子树
中序遍历：左子树---> 根结点 ---> 右子树
后序遍历：左子树 ---> 右子树 ---> 根结点
层次遍历：只需按层次遍历即可
```
遍历代码详见参考文档

&nbsp;
## reference
[3 分钟理解完全二叉树、平衡二叉树、二叉查找树](https://juejin.im/entry/5afb9fb66fb9a07ab458cc0d)  
[二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）](https://blog.csdn.net/My_Jobs/article/details/43451187)  
[数据结构：堆（Heap）](https://www.jianshu.com/p/6b526aa481b1)
