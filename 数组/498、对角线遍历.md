## 题目
给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:
```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:

 

说明:

给定矩阵中的元素总数不会超过 100000 。
```

&nbsp;
## 题解
### 方法一：对角线迭代和翻转
#### 思路
解决许多复杂问题的常见策略是首先解决该问题的简化问题，然后考虑从简化问题到原始问题需要做哪些修改，方法一就是这种思路。首先考虑按照逐条对角线打印元素，而不考虑翻转的情况。

#### 算法
```
1.每一趟对角线中元素的坐标（x, y）相加的和是递增的。
第一趟：1 的坐标(0, 0)。x + y == 0。
第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x + y == 1。
第三趟：7 的坐标(0, 2), 5 的坐标(1, 1)，3 的坐标(2, 0)。第三趟 x + y == 2。
第四趟：……

2.每一趟都是 x 或 y 其中一个从大到小（每次-1），另一个从小到大（每次+1）。
第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x 每次-1，y 每次+1。
第三趟：7 的坐标(0, 2), 5 的坐标(1, 1)，3 的坐标(2, 0)。x 每次 +1，y 每次 -1。

3.确定初始值。例如这一趟是 x 从大到小， x 尽量取最大，当初始值超过 x 的上限时，不足的部分加到 y 上面。
第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x + y == 1，x 初始值取 1，y 取 0。
第四趟：6 的坐标(2, 1)，8 的坐标(1, 2)。x + y == 3，x 初始值取 2，剩下的加到 y上，y 取 1。

4.确定结束值。例如这一趟是 x 从大到小，这一趟结束的判断是， x 减到 0 或者 y 加到上限。
第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x 减到 0 为止。
第四趟：6 的坐标(2, 1)，8 的坐标(1, 2)。x 虽然才减到 1，但是 y 已经加到上限了。

5.这一趟是 x 从大到小，那么下一趟是 y 从大到小，循环进行。 并且方向相反时，逻辑处理是一样的，除了x，y和他们各自的上限值是相反的。
x 从大到小，第二趟：2 的坐标(1, 0)，4 的坐标(0, 1)。x + y == 1，x 初始值取 1，y 取 0。结束值 x 减到 0 为止。
x 从小到大，第三趟：7 的坐标(0, 2)，5 的坐标(1, 1)，3 的坐标(2, 0)。x + y == 2，y 初始值取 2，x 取 0。结束值 y 减到 0 为止。

```
链接：https://leetcode-cn.com/problems/diagonal-traverse/solution/dui-jiao-xian-bian-li-fen-xi-ti-mu-zhao-zhun-gui-l/

```
vector<int> nums;
int m = matrix.size();
int n = matrix[0].size();

int i = 0;	// i 是 x + y 的和
while (i < m + n)
{
	// 第 1 3 5 ... 趟
	int x1 = (i < m) ? i : m - 1;	// 确定 x y 的初始值
	int y1 = i - x1;
	while (x1 >= 0 && y1 < n)
	{
		nums.push_back(matrix[x1][y1]);
		x1--;
		y1++;
	}
	i++;

	if (i >= m + n) break;
	// 第 2 4 6 ... 趟
	int y2 = (i < n) ? i : n - 1;	// 确定 x y 的初始值
	int x2 = i - y2;
	while (y2 >= 0 && x2 < m)
	{
		nums.push_back(matrix[x2][y2]);
		x2++;
		y2--;
	}
	i++;
}
return nums;
```
### 优化
无论这一趟的方向如何，逻辑处理是一样的，试着合并成一套。

bool bXFlag = true;
使用一个bool值标记，将用到的数据正确定位。例如：
// 5. 逻辑处理是一样的，x，y的上限值是相反的
......

链接：https://leetcode-cn.com/problems/diagonal-traverse/solution/dui-jiao-xian-bian-li-fen-xi-ti-mu-zhao-zhun-gui-l/

&nbsp;
## reference
[498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)
