## 题目
实现 pow(x, n) ，即计算 x 的 n 次幂函数。
```
示例 1:

输入: 2.00000, 10
输出: 1024.00000
示例 2:

输入: 2.10000, 3
输出: 9.26100
示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2^-2 = 1/2^2 = 1/4 = 0.25
说明:

-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 
```

&nbsp;
## 题解
### 前言
本题的方法被称为「快速幂算法」，有递归和迭代两个版本。这篇题解会从递归版本的开始讲起，再逐步引出迭代的版本。

当指数 n 为负数时，我们可以计算 x^−n 再取倒数得到结果，因此我们只需要考虑 n 为自然数的情况。

### 方法一：快速幂 + 递归
直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

当我们要计算 x^n 时，我们可以先递归地计算出 y=x^⌊n/2⌋，其中 ⌊a⌋ 表示对 a 进行下取整；

根据递归计算的结果，如果 n 为偶数，那么 x^n = y^2x ；如果 n 为奇数，那么 x^n = y^2 * x

递归的边界为 n=0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。

```
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def quickMul(N):
            if N == 0:
                return 1.0
            y = quickMul(N // 2)
            return y * y if N % 2 == 0 else y * y * x
        
        return quickMul(n) if n >= 0 else 1.0 / quickMul(-n)
```
#### 复杂度分析
时间复杂度：O(logn)，即为递归的层数。  
空间复杂度：O(logn)，即为递归的层数。这是由于递归的函数调用会使用栈空间。


### 方法二：快速幂 + 迭代
由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。

......

```
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def quickMul(N):
            ans = 1.0
            # 贡献的初始值为 x
            x_contribute = x
            # 在对 N 进行二进制拆分的同时计算答案
            while N > 0:
                if N % 2 == 1:
                    # 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                    ans *= x_contribute
                # 将贡献不断地平方
                x_contribute *= x_contribute
                # 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
                N //= 2
            return ans
        
        return quickMul(n) if n >= 0 else 1.0 / quickMul(-n)
```
#### 复杂度分析
时间复杂度：O(logn)，即为对 nn 进行二进制拆分的时间复杂度。   
空间复杂度：O(1)。

&nbsp;
## reference
[50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)
