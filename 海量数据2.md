# 统计不同号码数
### 题目描述
已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。

### 解答思路
这道题本质还是**求解数据重复的问题，对于这类问题，一般首先考虑位图法**。  
对于本题，8 位电话号码可以表示的号码个数为 10^8 个，即 1 亿个。  
我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。

### 思路如下：
申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。  
遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。
### 方法总结
求解数据重复问题，记得考虑位图法。

# 寻找中位数
### 题目描述
从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。  
当样本数为奇数时，中位数为 第 (N+1)/2 个数；  
当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。
### 解答思路
如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。  
但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。

### 方法一：双堆法
维护两个堆，一个大顶堆，一个小顶堆。  
**大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。**  
若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。  
当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。
#### 注意：
> 以上这种方法，需要把所有数据都加载到内存中。  
当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。  
5 亿个数，每个数字占用 4B，总共需要 2G 内存。  
如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。

### 方法二：分治法
分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。  
[python代码](https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/#comment)

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的**二进制中最高位**为，则把这个数字写到 f1 中，否则写入 f0 中。  
通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。  
划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。  
假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。  

对于 f0 可以用**次高位的二进制继续**将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。

*注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值*。

# 按频度排序
### 题目描述
有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，**每个文件的 query 都可能重复**。要求按照 query 的频度排序。
### 解答思路
如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；  
如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。
### 方法一：HashMap 法
如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。  
接着就可以按照 query 出现的次数进行排序。
### 方法二：分治法
分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。  

对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。   
**注：**hash的目的是把10个文件中相同的query放到一个文件中，因为题干‘**每个文件的 query 都可能重复**’。  
否则，分布在不同文件的相同的query无法汇总频度。

之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到另外一个单独文件中。

接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。
### 方法总结
> •内存若够，直接读入进行排序；  
•内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。
