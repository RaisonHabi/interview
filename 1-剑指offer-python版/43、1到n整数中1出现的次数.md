## 题解
### 数学规律
例子：  
从 1 至 2593 中，数字 5 总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。
#### 一、1的数目
编程之美上给出的规律：
```
如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），等于更高位数字X当前位数的权重10i-1。

如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），等于更高位数字X当前位数的权重10i-1+（低位数字+1）。

如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），等于（更高位数字+1）X当前位数的权重10i-1。
```
。。。  
### 找规律,递归的移动位数
总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时：
```
取第 i 位左边（高位）的数字，乘以 10i−1，得到基础值 a。
取第 i 位数字，计算修正值：
  如果大于 X，则结果为 a+10i−1。
  如果小于 X，则结果为 a。
  如果等 X，则取第 i 位右边（低位）数字，设为 b，最后结果为 a+b+1。
```
```
///自己写
def numberOf1(n):
  if n<1:return 0
  i,count=1,0
  while i<n:
    a=n//i
    b=n%i
    ### 分三种情况讨论；统计1的话比较特殊，两种就行
    if a%10>1:
      count+=(a//10)*i+i
    elif a%10==1:
      count+=(a//10)*i+(b+1)
    else:
      count+=(a//10)*i
    
    /// i位是否大于1
   //// count+=a//10*i+((a % 10 == 1) ? b + 1 : 0);
    i*=10
```
```
///参考代码
public int NumberOf1Between1AndN_Solution2(int n) {
    int count = 0;
    for (int i = 1; i <= n; i *= 10) {
        int a = n / i,b = n % i;
        //之所以补8，是因为当百位为0，则a/10==(a+8)/10，
        //当百位>=2，补8会产生进位位，效果等同于(a/10+1)
        count += (a + 8) / 10 * i + ((a % 10 == 1) ? b + 1 : 0);
    }
    return count;
}
```

&nbsp;
## reference
[剑指offer-整数中1出现的次数](https://blog.csdn.net/huzhigenlaohu/article/details/51779365)
