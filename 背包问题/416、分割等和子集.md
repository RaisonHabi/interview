## 一、题目描述
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:
每个数组中的元素不会超过 100 ,
数组的大小不会超过 200

示例 1:
```
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
```
示例 2:
```
输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
```

&nbsp;
## 二、题解
对于这个问题，我们可以先对集合求和，得出sum，把问题转化为背包问题：

给一个可装载重量为sum/2的背包和N个物品，每个物品的重量为nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？

你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，下面我们就直接转换成背包问题，开始套前文讲过的背包问题框架即可。
### 「状态」和「选择」
这个前文 经典动态规划：0-1 背包问题 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。
### 状态定义
按照背包问题的套路，可以给出如下定义：  
dp[i][j] = x表示，对于前i个物品，当前背包的容量为j时，若x为true，则说明可以恰好将背包装满，若x为false，则说明不能恰好将背包装满。
```
def canPartition(nums):
  sum=0
  for num in nums:
    sum+=num
    
  if sum%2:return False
  
  sum=sum//2
  n=len(nums)
  dp=[[False for i in range(sum+1)] for j in range(n)]
  
  // base case
  for i in range(n):
    dp[i][0]=True
  
  for i in range(n):
    for j in range(sum+1):
      // 背包容量不足，不能装入第 i 个物品
      if j-nums[i]<0:
        dp[i][j] = dp[i - 1][j]
      // 装入或不装入背包
      else:
        dp[i][j]=dp[i-1][j] or dp[i-1][j-nums[i]]
        
 
 return dp[n-1][sum]
```
### 进行状态压缩
再进一步，是否可以优化这个代码呢？注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的，之前的数据都不会再使用了。

所以，我们可以进行状态压缩，将二维dp数组压缩为一维，节约空间复杂度：
```
bool canPartition(vector<int>& nums) {
    int sum = 0, n = nums.size();
    for (int num : nums) sum += num;
    if (sum % 2 != 0) return false;
    sum = sum / 2;
    vector<bool> dp(sum + 1, false);
    // base case
    dp[0] = true;

    for (int i = 0; i < n; i++) 
        for (int j = sum; j >= 0; j--) 
            if (j - nums[i] >= 0) 
                dp[j] = dp[j] || dp[j - nums[i]];

    return dp[sum];
}
```
**需要注意的是j应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果**。

子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。 

&nbsp;  
## 三、题解2
思路：  
```
关于 0-1 背包问题的介绍，大家可以在互联网上搜索《背包九讲》进行相关知识的学习。本题解有些地方使用了 0-1 背包问题的描述，因此会不加解释的使用“背包”、“容量”这样的名词。
本题解按照动态规划的一般思考方向进行讲解（仅供参考，本人水平有限，大概觉得是这几个方面），它们是：
1、状态定义；
2、状态转移方程；
3、初始化；
4、输出；
5、思考状态压缩。
这 5 个部分是本题解的结构。其它类似的动态规划问题也可以按照这样的方向去思考、解释和理解。
```
事实上，这是一个典型的“动态规划”问题，并且它的“原形”是“0-1 背包问题”。
### **使用“动态规划”解决问题的思路是“以空间换时间”，“规划”这个词在英文中就是“填表格”的意思，代码执行的过程，也可以称之为“填表格”**。
```
“动态规划”的方法可以认为是为我们提供了一个思考问题的方向，我们不是直接面对问题求解，而是去找原始问题（或者说和原始问题相关的问题）的最开始的样子，
通过“状态转移方程”（这里没法再解释了，可以结合下文理解）记录下每一步求解的结果，直到最终问题解决。

而直接面对问题求解，就是我们熟悉的“递归”方法，由于有大量重复子问题，我们就需要加缓存，这叫“记忆化递归”，
这里就不给参考代码了，感兴趣的朋友可以自己写一下，比较一下它们两种思考方式的不同之处和优缺点。
```
做这道题需要做这样一个等价转换：是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。前提条件是：数组的和一定得是偶数，即数组的和一定得被 2 整除，这一点是特判。


&nbsp;
## reference
[经典动态规划：0-1背包问题的变体](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485103&idx=1&sn=8a9752e18ed528e5c18d973dcd134260&chksm=9bd7f8a7aca071b14c736a30ef7b23b80914c676414b01f8269808ef28da48eb13e90a432fff&scene=21#wechat_redirect)    
[动态规划（0-1 背包问题）](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/)
