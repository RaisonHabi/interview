## 一、题目描述
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:
每个数组中的元素不会超过 100 ,
数组的大小不会超过 200

示例 1:
```
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
```
示例 2:
```
输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
```

&nbsp;
## 二、题解
对于这个问题，我们可以先对集合求和，得出sum，把问题转化为背包问题：

给一个可装载重量为sum/2的背包和N个物品，每个物品的重量为nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？

你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，下面我们就直接转换成背包问题，开始套前文讲过的背包问题框架即可。
### 「状态」和「选择」
这个前文 经典动态规划：0-1 背包问题 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。
### 状态定义
按照背包问题的套路，可以给出如下定义：  
dp[i][j] = x表示，对于前i个物品，当前背包的容量为j时，若x为true，则说明可以恰好将背包装满，若x为false，则说明不能恰好将背包装满。

如果dp[4][9] = true，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。

由于i是从 1 开始的，而数组索引是从 0 开始的，所以第i个物品的重量应该是nums[i-1]，这一点不要搞混。
```
def canPartition(nums):
  sum=0
  for num in nums:
    sum+=num
    
  if sum%2:return False
  
  sum=sum//2
  n=len(nums)
  dp=[[False for i in range(sum+1)] for j in range(n+1)]
  
  // base case
  for i in range(n+1):
    dp[i][0]=True
  
  for i in range(1,n+1):
    for j in range(1,sum+1):
      // 背包容量不足，不能装入第 i 个物品
      if j-nums[i]<0:
        dp[i][j] = dp[i - 1][j]
      // 装入或不装入背包
      else:
        dp[i][j]=dp[i-1][j] or dp[i-1][j-nums[i-1]]
        
      // 由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作
      链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/
       if dp[i][sum]) :
           return true;

 return dp[n][sum]
```
### 进行状态压缩
再进一步，是否可以优化这个代码呢？注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的，之前的数据都不会再使用了。

所以，我们可以进行状态压缩，将二维dp数组压缩为一维，节约空间复杂度：
```
bool canPartition(vector<int>& nums) {
    int sum = 0, n = nums.size();
    for (int num : nums) sum += num;
    if (sum % 2 != 0) return false;
    sum = sum / 2;
    vector<bool> dp(sum + 1, false);
    // base case
    dp[0] = true;

    for (int i = 0; i < n; i++) 
        for (int j = sum; j >= 0; j--) 
            if dp[sum]:return True //由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作
            if (j - nums[i] >= 0) 
                dp[j] = dp[j] || dp[j - nums[i]];

    return dp[sum];
}
```
**需要注意的是j应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果**。  
这里可能会有人困惑为什么压缩到一维时，要采用逆序。因为在一维情况下，是根据 dp[j] || dp[j - nums[i]]来推d[j]的值，如不逆序，就无法保证在外循环 i 值保持不变 j 值递增的情况下，dp[j - num[i]]的值不会被当前所放入的nums[i]所修改，**当j值未到达临界条件前，会一直被nums[i]影响，也即是可能重复的放入了多次nums[i]，为了避免前面对后面产生影响，故用逆序**。   
举个例子，数组为[2,2,3,5]，要找和为6的组合，i = 0时，dp[2]为真，当i自增到1，j = 4时，nums[i] = 2,dp[4] = dp[4] || dp[4 - 2]为true，当i不变，j = 6时,dp[6] = dp [6] || dp [6 - 2],而dp[4]为true，所以dp[6] = true,显然是错误的。 故必须得纠正在正序情况下，i值不变时多次放入nums[i]的情况。

**如果是正序的话，后面dp访问前面的dp时得到的是已经更新的内容，此时求的是完全背包问题**。

子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。 

&nbsp;  
## 三、题解2
思路：  
```
关于 0-1 背包问题的介绍，大家可以在互联网上搜索《背包九讲》进行相关知识的学习。本题解有些地方使用了 0-1 背包问题的描述，因此会不加解释的使用“背包”、“容量”这样的名词。
本题解按照动态规划的一般思考方向进行讲解（仅供参考，本人水平有限，大概觉得是这几个方面），它们是：
1、状态定义；
2、状态转移方程；
3、初始化；
4、输出；
5、思考状态压缩。
这 5 个部分是本题解的结构。其它类似的动态规划问题也可以按照这样的方向去思考、解释和理解。
```
事实上，这是一个典型的“动态规划”问题，并且它的“原形”是“0-1 背包问题”。
### **使用“动态规划”解决问题的思路是“以空间换时间”，“规划”这个词在英文中就是“填表格”的意思，代码执行的过程，也可以称之为“填表格”**。
```
“动态规划”的方法可以认为是为我们提供了一个思考问题的方向，我们不是直接面对问题求解，而是去找原始问题（或者说和原始问题相关的问题）的最开始的样子，
通过“状态转移方程”（这里没法再解释了，可以结合下文理解）记录下每一步求解的结果，直到最终问题解决。

而直接面对问题求解，就是我们熟悉的“递归”方法，由于有大量重复子问题，我们就需要加缓存，这叫“记忆化递归”，
这里就不给参考代码了，感兴趣的朋友可以自己写一下，比较一下它们两种思考方式的不同之处和优缺点。
```
做这道题需要做这样一个等价转换：是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。前提条件是：数组的和一定得是偶数，即数组的和一定得被 2 整除，这一点是特判。


&nbsp;
## reference
[经典动态规划：0-1背包问题的变体](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485103&idx=1&sn=8a9752e18ed528e5c18d973dcd134260&chksm=9bd7f8a7aca071b14c736a30ef7b23b80914c676414b01f8269808ef28da48eb13e90a432fff&scene=21#wechat_redirect)    
[动态规划（0-1 背包问题）](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/)
